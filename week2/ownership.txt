Example 1:
```
fn main() {
    let mut s = String::from("hello");
    let ref1 = &s;
    let ref2 = &ref1;
    let ref3 = &ref2;
    s = String::from("goodbye");
    println!("{}", ref3.to_uppercase());
}
```
It does not compile. One key rule of Rust is we cannot modify a value until there are immutable references or borrowers to string. Since we are using refernces after modifying string too so rust compiler cannot drop references and since references are alive during modifying, it is voilation of rule of Rust.  

Example 2:
```
fn drip_drop() -> &String {
    let s = String::from("hello world!");
    return &s;
}
```
This does not compile.
When function ends, s goes out of scope and is dropped. Since a reference to s is being returned which gets deallocated after function ends, returned reference becomes a dangling reference.

Example 3:
```
fn main() {
    let s1 = String::from("hello");
    let mut v = Vec::new();
    v.push(s1);
    let s2: String = v[0];
    println!("{}", s2);
}
```
This does not compile.
Since string does not implement copy trait, we try to transfer ownership by assigning v[0] to s2 but that value belongs to vector and it cannot be pulled out of its index.